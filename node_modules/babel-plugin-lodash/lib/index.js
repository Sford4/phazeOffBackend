"use strict";

exports.__esModule = true;
exports.default = lodash;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _each2 = _interopRequireDefault(require("lodash/each"));

var _assign3 = _interopRequireDefault(require("lodash/assign"));

var _types = require("@babel/types");

var _config = _interopRequireDefault(require("./config"));

var _importModule3 = _interopRequireDefault(require("./importModule"));

var _mapping = _interopRequireDefault(require("./mapping"));

var _Store = _interopRequireDefault(require("./Store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** The error message used when chain sequences are detected. */
const CHAIN_ERROR = ['Lodash chain sequences are not supported by babel-plugin-lodash.', 'Consider substituting chain sequences with composition patterns.', 'See https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba'].join('\n');
/*----------------------------------------------------------------------------*/

function lodash({
  types
}) {
  const identifiers = {
    'PLACEHOLDER': types.identifier('placeholder'),
    'UNDEFINED': types.identifier('undefined')
    /**
     * Used to track variables built during the AST pass. We instantiate these in
     * the `Program` visitor in order to support running the plugin in watch mode
     * or on multiple files.
     *
     * @type Store
     */

  };
  const store = new _Store.default();

  function getCallee({
    parentPath
  }) {
    // Trace curried calls to their origin, e.g. `fp.partial(func)([fp, 2])(1)`.
    while (!parentPath.isStatement()) {
      if (parentPath.isCallExpression()) {
        let result = parentPath.node.callee;

        while (types.isCallExpression(result)) {
          result = result.callee;
        }

        return result;
      }

      parentPath = parentPath.parentPath;
    }
  }
  /*--------------------------------------------------------------------------*/


  const visitor = {
    Program(path, state) {
      const _assign2 = (0, _assign3.default)(_mapping.default, (0, _config.default)(state.opts)),
            ids = _assign2.ids;

      const file = path.hub.file; // Clear tracked method imports.

      _importModule3.default.cache.clear();

      store.clear(); // Populate module paths per package.

      (0, _each2.default)(ids, id => {
        store.set(id);

        _mapping.default.modules.get(id).forEach((value, key) => {
          store.set(id + '/' + key);
        });
      });
      const imports = [];
      let isModule = false;

      for (var _iterator = file.ast.program.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        const node = _ref;

        if ((0, _types.isModuleDeclaration)(node)) {
          isModule = true;
          break;
        }
      }

      if (isModule) {
        file.path.traverse({
          ImportDeclaration: {
            exit(path) {
              const node = path.node;
              const imported = [];
              const specifiers = [];
              imports.push({
                source: node.source.value,
                imported,
                specifiers
              });

              for (var _iterator2 = path.get("specifiers"), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                const specifier = _ref2;
                const local = specifier.node.local.name;

                if (specifier.isImportDefaultSpecifier()) {
                  imported.push("default");
                  specifiers.push({
                    kind: "named",
                    imported: "default",
                    local
                  });
                }

                if (specifier.isImportSpecifier()) {
                  const importedName = specifier.node.imported.name;
                  imported.push(importedName);
                  specifiers.push({
                    kind: "named",
                    imported: importedName,
                    local
                  });
                }

                if (specifier.isImportNamespaceSpecifier()) {
                  imported.push("*");
                  specifiers.push({
                    kind: "namespace",
                    local
                  });
                }
              }
            }

          }
        });
      } // Replace old members with their method imports.


      (0, _each2.default)(imports, module => {
        const pkgStore = store.get(module.source);

        if (!pkgStore) {
          return;
        }

        const isLodash = pkgStore.isLodash();
        const specs = (0, _sortBy2.default)(module.specifiers, spec => spec.imported === 'default');
        (0, _each2.default)(specs, spec => {
          const imported = spec.imported,
                local = spec.local;
          const binding = file.scope.getBinding(local);
          const _binding$path$parent$ = binding.path.parent.importKind,
                importKind = _binding$path$parent$ === void 0 ? 'value' : _binding$path$parent$; // Skip type annotation imports.

          if (importKind != 'value') {
            return;
          }

          const isChain = isLodash && imported === 'chain';
          (0, _each2.default)(binding.referencePaths, refPath => {
            const node = refPath.node,
                  parentPath = refPath.parentPath;
            const type = node.type;

            if (imported && imported !== 'default') {
              if (isChain && refPath.parentPath.isCallExpression()) {
                throw refPath.buildCodeFrameError(CHAIN_ERROR);
              }

              const _importModule = (0, _importModule3.default)(pkgStore, imported, refPath),
                    name = _importModule.name;

              refPath.replaceWith({
                type,
                name
              });
            } else if (parentPath.isMemberExpression()) {
              const key = refPath.parent.property.name;

              if (isLodash && key === 'chain' && parentPath.parentPath.isCallExpression()) {
                throw refPath.buildCodeFrameError(CHAIN_ERROR);
              }

              const _importModule2 = (0, _importModule3.default)(pkgStore, key, refPath),
                    name = _importModule2.name;

              parentPath.replaceWith({
                type,
                name
              });
            } else if (isLodash) {
              const callee = getCallee(refPath);

              if (callee && callee.name === local) {
                throw refPath.buildCodeFrameError(CHAIN_ERROR);
              }

              refPath.replaceWith(callee ? types.memberExpression(callee, identifiers.PLACEHOLDER) : identifiers.UNDEFINED);
            }
          });
        });
      });
    },

    ImportDeclaration(path) {
      if (store.get(path.node.source.value)) {
        // Remove old import.
        path.remove();
      }
    },

    ExportNamedDeclaration(path) {
      const node = path.node;
      const pkgPath = (0, _get2.default)(node, 'source.value');
      const pkgStore = store.get(pkgPath);

      if (!pkgStore) {
        return;
      }

      node.source = null;
      (0, _each2.default)(node.specifiers, spec => {
        spec.local = (0, _importModule3.default)(pkgStore, spec.local.name, path);
      });
    }

  };
  return {
    visitor
  };
}

module.exports = exports["default"];